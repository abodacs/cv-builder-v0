from contextlib import suppress

from fastapi import FastAPI, WebSocket

from app.core.constants import PERSONAL_INFO_FIELDS
from app.core.state import CVState
from app.services.redis_store import RedisStore
from app.services.workflow import graph

redis_store = RedisStore()


async def handle_websocket(websocket: WebSocket) -> None:
    await websocket.accept()
    session_id = None
    state = None  # Initialize state

    try:
        # Receive initial message with session ID
        data = await websocket.receive_json()
        session_id = data.get("session_id")
        language = data.get("language", "ar")
        if not session_id:
            await websocket.send_json(
                {
                    "sender": "Chatbot",
                    "text": "خطأ: لم يتم تقديم معرف الجلسة."
                    if language == "ar"
                    else "Error: No session ID provided.",
                    "language": language,
                }
            )
            await websocket.close()
            return
        print(f"\n[Session: {session_id}] Connection established. Language: {language}")
        # Load or initialize state
        state = redis_store.load_state(session_id)
        if state:
            print(
                f"[Session: {session_id}] Loaded existing state. Current section: {state.current_section}, Field: {state.current_field}"
            )
            # If loaded state is already complete, send final message and exit loop early
            if state.is_complete and state.cv_output:
                await websocket.send_json(
                    {"sender": "Chatbot", "text": state.cv_output}
                )
                # Keep connection open but don't enter main loop? Or close?
                # Let's close for simplicity after sending final msg.
                await websocket.close()
                return
            # Refresh language if provided in initial message? Usually no. Stick with saved language.
            # state.language = language # Decide if language override is desired on reconnect
            # Ensure chatbot_response is cleared if we are generating a fresh prompt
            state.chatbot_response = None
            state.user_input = None  # Clear any stale input
        else:
            print(
                f"[Session: {session_id}] No existing state found. Initializing new state."
            )
            # Initialize new state, ensuring current_field is set for personal_info
            state = CVState(
                language=language,
                current_section="personal_info",
                current_field=PERSONAL_INFO_FIELDS[0],
            )

        # === Run Graph for Initial Prompt ===
        # Invoke graph with the initial/loaded state (without user input yet)
        # The process_input node will do nothing (no user input),
        # then generate_prompt will create the first question.
        print(f"[Session: {session_id}] Running graph for initial prompt...")
        initial_state_dict = await graph.ainvoke(
            state.dict(), config={"recursion_limit": 5}
        )  # Limit depth for safety
        state = CVState(**initial_state_dict)
        redis_store.save_state(
            session_id, state
        )  # Save the state *after* getting the initial prompt

        # Send the initial/current prompt
        response_to_send = (
            state.cv_output if state.is_complete else state.chatbot_response
        )
        # Send the first prompt
        if state.chatbot_response:
            await websocket.send_json(
                {"sender": "Chatbot", "text": state.chatbot_response}
            )
            print(
                f"[Session: {session_id}] Sent initial prompt: {state.chatbot_response[:80]}..."
            )
        else:
            print(
                f"[Session: {session_id}] Warning: No initial prompt generated by graph."
            )
            await websocket.send_json(
                {"sender": "Chatbot", "text": "Welcome! Let's start building your CV."}
            )  # Fallback

        # === Message Loop ===
        while not state.is_complete:
            data = await websocket.receive_json()
            received_session_id = data.get("session_id")
            user_input = data.get("text", "").strip()

            if received_session_id != session_id:
                await websocket.send_json(
                    {"sender": "Chatbot", "text": "Error: Session ID mismatch."}
                )
                continue  # Or close

            if not user_input:
                # Re-send the last prompt if input is empty
                if state.chatbot_response:
                    await websocket.send_json(
                        {
                            "sender": "Chatbot",
                            "text": f"Please provide a response. {state.chatbot_response}",
                        }
                    )
                else:
                    await websocket.send_json(
                        {"sender": "Chatbot", "text": "Please provide a response."}
                    )
                continue

            print(f"\n[Session: {session_id}] Received input: {user_input}")

            # Load the latest state before processing
            current_state = redis_store.load_state(session_id)
            if not current_state:
                print(
                    f"[Session: {session_id}] Error: Session expired or not found during loop."
                )
                await websocket.send_json(
                    {
                        "sender": "Chatbot",
                        "text": "Error: Session expired or not found.",
                    }
                )
                break  # Exit loop

            # Prepare state for the graph: add user input
            current_state.user_input = user_input

            current_state.chatbot_response = (
                None  # Clear previous response before graph run
            )

            # Invoke the graph for one turn
            print(
                f"[Session: {session_id}] Invoking graph. Section: {current_state.current_section}, Field: {current_state.current_field}"
            )
            result_state_dict = await graph.ainvoke(
                current_state.dict(), config={"recursion_limit": 50}
            )
            state = CVState(**result_state_dict)  # Update local state variable

            print(
                f"[Session: {session_id}] Graph finished. Next section: {state.current_section}, Next field: {state.current_field}, Complete: {state.is_complete}"
            )

            # Save the *new* state returned by the graph
            redis_store.save_state(session_id, state)

            # Send the response generated by the graph
            response_to_send = (
                state.cv_output if state.is_complete else state.chatbot_response
            )
            if response_to_send:
                await websocket.send_json(
                    {"sender": "Chatbot", "text": response_to_send}
                )
                # print(f"[Session: {session_id}] Sent response: {response_to_send[:80]}...")
            else:
                # This might happen if is_complete=True but cv_output is somehow None, or an error occurred
                print(
                    f"[Session: {session_id}] Warning: No response generated by graph."
                )
                if state.is_complete:
                    await websocket.send_json(
                        {"sender": "Chatbot", "text": "CV generation process finished."}
                    )  # Fallback completion message

        # === End of Conversation ===
        if state and state.is_complete:
            print(f"Session complete: {session_id}")
            # Optional: Clean up Redis immediately, or rely on TTL
            # redis_client.delete(f"cv_session:{session_id}")

    except Exception as e:
        print(f"WebSocket Error (Session: {session_id}): {e}")
        import traceback

        traceback.print_exc()  # Print full traceback to server console for debugging
        with suppress(Exception):
            await websocket.send_json(
                {"sender": "Chatbot", "text": f"An server error occurred: {e!s}"}
            )
        await websocket.close()

    finally:
        await websocket.close()


def register_websocket_handler(app: FastAPI) -> None:
    """Register WebSocket endpoint with FastAPI app."""
    app.websocket("/ws/cv_builder")(handle_websocket)
